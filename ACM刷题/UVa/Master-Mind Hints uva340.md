# 题目

## 题面翻译

你的任务是实现一个经典的“猜数字”游戏。给定答案序列和用户猜的序列，统计有多少数字位置正确（设为$A$ ），有多少数字在两个序列中都出现过但位置不对（$B$ ）。

输入包含多组数据。每组输入第一行为序列长度$n$ ，第二行是答案序列，接下来是若干行猜测序列。猜测序列全$0$ 时表示该组数据结束。$n=0$ 时输入结束。

对于每一组数据，输出的开头应有一行**“Game x:”**（没有双引号，x为当前组数据的编号，从1开始递增），然后对于每个猜测序列，输出一组数，格式**(A,B)**，A,B的意义如上所示，注意在**(A,B)**之前要输出四个空格符。

## 样例 #1

### 样例输入 #1

```
4
1 3 5 5
1 1 2 3
4 3 3 5
6 5 5 1
6 1 3 5
1 3 5 5
0 0 0 0
10
1 2 2 2 4 5 6 6 6 9
1 2 3 4 5 6 7 8 9 1
1 1 2 2 3 3 4 4 5 5
1 2 1 3 1 5 1 6 1 9
1 2 2 5 5 5 6 6 6 7
0 0 0 0 0 0 0 0 0 0
0
```

### 样例输出 #1

```
Game 1:
    (1,1)
    (2,0)
    (1,2)
    (1,2)
    (4,0)
Game 2:
    (2,4)
    (3,2)
    (5,0)
    (7,0)
```

# 题解

- 求A：直接在输入猜测序列就统计与答案序列相同的数的个数

- 求B：对于`1~9`的每一个数`x`，都对两个序列进行一次遍历，并且分别统计`x`在两个序列中出现的次数`c1` `c2`，然后将`min(c1,c2)`值累加到`B`中，最后`B`值还需要减去`A`值。

  - 例如，数字`1`在答案序列中出现了`2`次，在猜测序列中出现了`1`次，而我们要求的是两个序列中都有的次数。所以，只能取最小值`1`

  - 此时`B`中储存的是两个序列中相同数字的个数，而`A`储存的是位置正确的数字个数，`B`所要储存的值是在两个序列中都出现过但位置不对的数字的个数，所以`B`的值还要减去`A`

```cpp
#include<stdio.h>
#include<algorithm>
using namespace std;

int main()
{
	int n,index=1;
	while(scanf("%d",&n)==1)
	{
		if(n==0)
			break;
		printf("Game %d:\n",index++);
		int *ans=new int[n];
		for(int i=0;i<n;i++)
			scanf("%d",&ans[i]);
		while(1)
		{
			int *gue=new int[n];
			int A=0,B=0;
			for(int j=0;j<n;j++)
			{
				scanf("%d",&gue[j]);
				if(gue[j]==ans[j])
					A++;
			}
			if(gue[0]==0)
				break;
			for(int k=1;k<=9;k++)
			{
				int c1=0,c2=0;
				for(int p=0;p<n;p++)
				{
					if(ans[p]==k)
						c1++;
					if(gue[p]==k)
						c2++;
				}
				B+=min(c1,c2);
			}
			printf("    (%d,%d)\n",A,B-A);
			delete []gue;
		}
		delete []ans;
	}
	return 0;
}
```

